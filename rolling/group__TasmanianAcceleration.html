<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v7.1 (development): Classes and functions used for acceleration methods</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tasmanian.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">Toolkit for Adaptive Stochastic Modeling and Non-Intrusive ApproximatioN: Tasmanian v7.1 (development)
           <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__TasmanianAcceleration.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Classes and functions used for acceleration methods<div class="ingroups"><a class="el" href="group__TasmanianSG.html">Sparse Grids</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Classes and functions used for acceleration methods:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__TasmanianAcceleration.png" border="0" alt="" usemap="#group____TasmanianAcceleration"/>
<map name="group____TasmanianAcceleration" id="group____TasmanianAcceleration">
<area shape="rect" id="node2" href="group__TasmanianSG.html" title="Sparse Grids" alt="" coords="5,20,109,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:tsgHiddenExternals_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgHiddenExternals_8hpp.html">tsgHiddenExternals.hpp</a></td></tr>
<tr class="memdesc:tsgHiddenExternals_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers to BLAS functionality. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tsgAcceleratedDataStructures_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgAcceleratedDataStructures_8hpp.html">tsgAcceleratedDataStructures.hpp</a></td></tr>
<tr class="memdesc:tsgAcceleratedDataStructures_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures for interacting with CUDA and MAGMA environments. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:tsgCacheLagrange_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsgCacheLagrange_8hpp.html">tsgCacheLagrange.hpp</a></td></tr>
<tr class="memdesc:tsgCacheLagrange_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache data structure for evaluate with Global grids. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasBLAS"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasBLAS.html">TasGrid::TasBLAS</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasBLAS"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers for BLAS methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1TasCUDA"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1TasCUDA.html">TasGrid::TasCUDA</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1TasCUDA"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrappers around custom CUDA kernels to handle domain transforms and basis evaluations, the kernels are instantiated in tsgCudaKernels.cu. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTasGrid_1_1AccelerationMeta"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTasGrid_1_1AccelerationMeta.html">TasGrid::AccelerationMeta</a></td></tr>
<tr class="memdesc:namespaceTasGrid_1_1AccelerationMeta"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common methods for manipulating acceleration options and reading CUDA environment properties. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CudaVector.html">TasGrid::CudaVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class that wraps around a single CUDA array, providing functionality that mimics std::vector.  <a href="classTasGrid_1_1CudaVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CudaEngine.html">TasGrid::CudaEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class around calls to cuBlas, cuSparse, and MAGMA for CUDA based accelerated linear algebra.  <a href="classTasGrid_1_1CudaEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1AccelerationDomainTransform.html">TasGrid::AccelerationDomainTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the domain transform algorithms in case the user data is provided on the GPU.  <a href="classTasGrid_1_1AccelerationDomainTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTasGrid_1_1CacheLagrange.html">TasGrid::CacheLagrange&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache that holds the values of 1D Lagrange polynomials.  <a href="classTasGrid_1_1CacheLagrange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga61035998929e409891c7b113651f2051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61035998929e409891c7b113651f2051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga61035998929e409891c7b113651f2051">TasGrid::TasCUDA::dtrans2can</a> (bool use01, int dims, int num_x, int pad_size, const double *gpu_trans_a, const double *gpu_trans_b, const T *gpu_x_transformed, T *gpu_x_canonical)</td></tr>
<tr class="memdesc:ga61035998929e409891c7b113651f2051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses custom kernel to convert <b>transformed</b> points to <b>canonical</b> points, all arrays live on the CUDA device.  <a href="group__TasmanianAcceleration.html#ga61035998929e409891c7b113651f2051">More...</a><br /></td></tr>
<tr class="separator:ga61035998929e409891c7b113651f2051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487792341ced3451cae56b4afeeb21cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga487792341ced3451cae56b4afeeb21cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga487792341ced3451cae56b4afeeb21cd">TasGrid::TasCUDA::devalpwpoly</a> (int order, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, int num_dimensions, int num_x, int num_basis, const T *gpu_x, const T *gpu_nodes, const T *gpu_support, T *gpu_y)</td></tr>
<tr class="memdesc:ga487792341ced3451cae56b4afeeb21cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the basis functions for a local polynomial grid using the <b>DENSE</b> algorithm.  <a href="group__TasmanianAcceleration.html#ga487792341ced3451cae56b4afeeb21cd">More...</a><br /></td></tr>
<tr class="separator:ga487792341ced3451cae56b4afeeb21cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd5f8cfd7fb8789dedfe6df281c93fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9dd5f8cfd7fb8789dedfe6df281c93fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga9dd5f8cfd7fb8789dedfe6df281c93fe">TasGrid::TasCUDA::devalpwpoly_sparse</a> (int order, <a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a> rule, int dims, int num_x, int num_points, const T *gpu_x, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;gpu_nodes, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;gpu_support, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;gpu_hpntr, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;gpu_hindx, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;gpu_hroots, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;gpu_spntr, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;gpu_sindx, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;gpu_svals)</td></tr>
<tr class="memdesc:ga9dd5f8cfd7fb8789dedfe6df281c93fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the basis functions for a local polynomial grid using the <b>SPARSE</b> algorithm.  <a href="group__TasmanianAcceleration.html#ga9dd5f8cfd7fb8789dedfe6df281c93fe">More...</a><br /></td></tr>
<tr class="separator:ga9dd5f8cfd7fb8789dedfe6df281c93fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ad47955a961ca1f8fe8edbf145e023"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08ad47955a961ca1f8fe8edbf145e023"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga08ad47955a961ca1f8fe8edbf145e023">TasGrid::TasCUDA::devalseq</a> (int dims, int num_x, const std::vector&lt; int &gt; &amp;max_levels, const T *gpu_x, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;num_nodes, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;points, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;nodes, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;coeffs, T *gpu_result)</td></tr>
<tr class="memdesc:ga08ad47955a961ca1f8fe8edbf145e023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the basis for a Sequence grid.  <a href="group__TasmanianAcceleration.html#ga08ad47955a961ca1f8fe8edbf145e023">More...</a><br /></td></tr>
<tr class="separator:ga08ad47955a961ca1f8fe8edbf145e023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c56ddb709fef22da7d0d8bcb1c79f11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7c56ddb709fef22da7d0d8bcb1c79f11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga7c56ddb709fef22da7d0d8bcb1c79f11">TasGrid::TasCUDA::devalfor</a> (int dims, int num_x, const std::vector&lt; int &gt; &amp;max_levels, const T *gpu_x, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;num_nodes, const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;points, T *gpu_wreal, typename <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt;::value_type *gpu_wimag)</td></tr>
<tr class="memdesc:ga7c56ddb709fef22da7d0d8bcb1c79f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the basis for a Fourier grid.  <a href="group__TasmanianAcceleration.html#ga7c56ddb709fef22da7d0d8bcb1c79f11">More...</a><br /></td></tr>
<tr class="separator:ga7c56ddb709fef22da7d0d8bcb1c79f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c22f5fc8cf3679ec0b1c9f70db82dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37c22f5fc8cf3679ec0b1c9f70db82dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga37c22f5fc8cf3679ec0b1c9f70db82dc">TasGrid::TasCUDA::devalglo</a> (bool is_nested, bool is_clenshawcurtis0, int dims, int num_x, int num_p, int num_basis, T const *gpu_x, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; const &amp;nodes, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; const &amp;coeff, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; const &amp;tensor_weights, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;nodes_per_level, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;offset_per_level, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;map_dimension, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;map_level, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;active_tensors, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;active_num_points, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;dim_offsets, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;map_tensor, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;map_index, <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;map_reference, T *gpu_result)</td></tr>
<tr class="memdesc:ga37c22f5fc8cf3679ec0b1c9f70db82dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the basis for Global grid.  <a href="group__TasmanianAcceleration.html#ga37c22f5fc8cf3679ec0b1c9f70db82dc">More...</a><br /></td></tr>
<tr class="separator:ga37c22f5fc8cf3679ec0b1c9f70db82dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae184192f6d2bca2a9887d36db62668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga7ae184192f6d2bca2a9887d36db62668">TasGrid::AccelerationMeta::getIOAccelerationString</a> (const char *name)</td></tr>
<tr class="memdesc:ga7ae184192f6d2bca2a9887d36db62668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string (coming from C or Python) into an enumerated type.  <a href="group__TasmanianAcceleration.html#ga7ae184192f6d2bca2a9887d36db62668">More...</a><br /></td></tr>
<tr class="separator:ga7ae184192f6d2bca2a9887d36db62668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e20edfabde6a82e74b40fb6bac1047"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gac2e20edfabde6a82e74b40fb6bac1047">TasGrid::AccelerationMeta::getIOAccelerationString</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> accel)</td></tr>
<tr class="memdesc:gac2e20edfabde6a82e74b40fb6bac1047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the enumerated type to a string, the inverse of <b><a class="el" href="group__TasmanianAcceleration.html#ga7ae184192f6d2bca2a9887d36db62668" title="Convert the string (coming from C or Python) into an enumerated type. ">getIOAccelerationString()</a></b>  <a href="group__TasmanianAcceleration.html#gac2e20edfabde6a82e74b40fb6bac1047">More...</a><br /></td></tr>
<tr class="separator:gac2e20edfabde6a82e74b40fb6bac1047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10839c9ae1b3663b8746b56d83fc081f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga10839c9ae1b3663b8746b56d83fc081f">TasGrid::AccelerationMeta::getIOAccelerationInt</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> accel)</td></tr>
<tr class="memdesc:ga10839c9ae1b3663b8746b56d83fc081f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the integer (coming from Fortran) into an enumerated type.  <a href="group__TasmanianAcceleration.html#ga10839c9ae1b3663b8746b56d83fc081f">More...</a><br /></td></tr>
<tr class="separator:ga10839c9ae1b3663b8746b56d83fc081f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685cda2cf2d7660ee8f630fa8f2ca647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga685cda2cf2d7660ee8f630fa8f2ca647">TasGrid::AccelerationMeta::getIOIntAcceleration</a> (int accel)</td></tr>
<tr class="memdesc:ga685cda2cf2d7660ee8f630fa8f2ca647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the enumerated type to an integer, the inverse of <b><a class="el" href="group__TasmanianAcceleration.html#ga10839c9ae1b3663b8746b56d83fc081f" title="Convert the integer (coming from Fortran) into an enumerated type. ">getIOAccelerationInt()</a></b>  <a href="group__TasmanianAcceleration.html#ga685cda2cf2d7660ee8f630fa8f2ca647">More...</a><br /></td></tr>
<tr class="separator:ga685cda2cf2d7660ee8f630fa8f2ca647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e7f9cea7355424ac39b404657a30bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga61e7f9cea7355424ac39b404657a30bc">TasGrid::AccelerationMeta::isAccTypeGPU</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> accel)</td></tr>
<tr class="memdesc:ga61e7f9cea7355424ac39b404657a30bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if <b>accele</b> is cuda, cublas or magma.  <a href="group__TasmanianAcceleration.html#ga61e7f9cea7355424ac39b404657a30bc">More...</a><br /></td></tr>
<tr class="separator:ga61e7f9cea7355424ac39b404657a30bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a698d63fdc95b913db1ea966dda5eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gae5a698d63fdc95b913db1ea966dda5eb">TasGrid::AccelerationMeta::getAvailableFallback</a> (<a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> accel)</td></tr>
<tr class="memdesc:gae5a698d63fdc95b913db1ea966dda5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements fallback logic, if <b>accel</b> has been enabled through CMake then this returns <b>accel</b>, otherwise it returns the "next-best-thing".  <a href="group__TasmanianAcceleration.html#gae5a698d63fdc95b913db1ea966dda5eb">More...</a><br /></td></tr>
<tr class="separator:gae5a698d63fdc95b913db1ea966dda5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a279855d78d5ab68875e7d46231621e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga1a279855d78d5ab68875e7d46231621e">TasGrid::AccelerationMeta::getNumCudaDevices</a> ()</td></tr>
<tr class="memdesc:ga1a279855d78d5ab68875e7d46231621e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of visible CUDA devices, uses cudaGetDeviceCount() (see the Nvidia documentation).  <a href="group__TasmanianAcceleration.html#ga1a279855d78d5ab68875e7d46231621e">More...</a><br /></td></tr>
<tr class="separator:ga1a279855d78d5ab68875e7d46231621e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69cd13800b0e80a73e624dcae1ffc7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga69cd13800b0e80a73e624dcae1ffc7f6">TasGrid::AccelerationMeta::setDefaultCudaDevice</a> (int deviceID)</td></tr>
<tr class="memdesc:ga69cd13800b0e80a73e624dcae1ffc7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the active device for this CPU thread using cudaSetDevice() (see the Nvidia documentation).  <a href="group__TasmanianAcceleration.html#ga69cd13800b0e80a73e624dcae1ffc7f6">More...</a><br /></td></tr>
<tr class="separator:ga69cd13800b0e80a73e624dcae1ffc7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecd328232c62eeba7fc02f84bc8ac62c"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gaecd328232c62eeba7fc02f84bc8ac62c">TasGrid::AccelerationMeta::getTotalGPUMemory</a> (int deviceID)</td></tr>
<tr class="memdesc:gaecd328232c62eeba7fc02f84bc8ac62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory available in the device (in units of bytes), uses cudaGetDeviceProperties() (see the Nvidia documentation).  <a href="group__TasmanianAcceleration.html#gaecd328232c62eeba7fc02f84bc8ac62c">More...</a><br /></td></tr>
<tr class="separator:gaecd328232c62eeba7fc02f84bc8ac62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93e9af5b4f1c940109194cb93c77e49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gab93e9af5b4f1c940109194cb93c77e49">TasGrid::AccelerationMeta::getCudaDeviceName</a> (int deviceID)</td></tr>
<tr class="memdesc:gab93e9af5b4f1c940109194cb93c77e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a character array that is a copy of the CUDA device name, uses cudaGetDeviceProperties() (see the Nvidia documentation).  <a href="group__TasmanianAcceleration.html#gab93e9af5b4f1c940109194cb93c77e49">More...</a><br /></td></tr>
<tr class="separator:gab93e9af5b4f1c940109194cb93c77e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20fa738772cd08992706e30045a5569"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab20fa738772cd08992706e30045a5569"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gab20fa738772cd08992706e30045a5569">TasGrid::AccelerationMeta::recvCudaArray</a> (size_t num_entries, const T *gpu_data, std::vector&lt; T &gt; &amp;cpu_data)</td></tr>
<tr class="memdesc:gab20fa738772cd08992706e30045a5569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a device array to the main memory, used for testing only, always favor using <b><a class="el" href="classTasGrid_1_1CudaVector.html" title="Template class that wraps around a single CUDA array, providing functionality that mimics std::vector...">CudaVector</a></b> (if possible).  <a href="group__TasmanianAcceleration.html#gab20fa738772cd08992706e30045a5569">More...</a><br /></td></tr>
<tr class="separator:gab20fa738772cd08992706e30045a5569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1217bdc16f561392b66e9af4b72d4f82"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1217bdc16f561392b66e9af4b72d4f82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga1217bdc16f561392b66e9af4b72d4f82">TasGrid::AccelerationMeta::delCudaArray</a> (T *x)</td></tr>
<tr class="memdesc:ga1217bdc16f561392b66e9af4b72d4f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate device array, used primarily for testing, always favor using <b><a class="el" href="classTasGrid_1_1CudaVector.html" title="Template class that wraps around a single CUDA array, providing functionality that mimics std::vector...">CudaVector</a></b> (if possible).  <a href="group__TasmanianAcceleration.html#ga1217bdc16f561392b66e9af4b72d4f82">More...</a><br /></td></tr>
<tr class="separator:ga1217bdc16f561392b66e9af4b72d4f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3026accc87a8033e8f64436fbee6bb"><td class="memItemLeft" align="right" valign="top"><a id="ga9c3026accc87a8033e8f64436fbee6bb"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga9c3026accc87a8033e8f64436fbee6bb">TasGrid::AccelerationMeta::createCublasHandle</a> ()</td></tr>
<tr class="memdesc:ga9c3026accc87a8033e8f64436fbee6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new cuBlas handle, used in unit-testing only. <br /></td></tr>
<tr class="separator:ga9c3026accc87a8033e8f64436fbee6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4100c3ef9cd49043058f09385015dd2"><td class="memItemLeft" align="right" valign="top"><a id="gac4100c3ef9cd49043058f09385015dd2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gac4100c3ef9cd49043058f09385015dd2">TasGrid::AccelerationMeta::deleteCublasHandle</a> (void *)</td></tr>
<tr class="memdesc:gac4100c3ef9cd49043058f09385015dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the cuBlas handle, used in unit-testing only. <br /></td></tr>
<tr class="separator:gac4100c3ef9cd49043058f09385015dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67931ed3a58b5b1714e754c0b318f378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga67931ed3a58b5b1714e754c0b318f378">TasGrid::AccelerationMeta::cudaCheckError</a> (void *cudaStatus, const char *info)</td></tr>
<tr class="memdesc:ga67931ed3a58b5b1714e754c0b318f378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes <b>cudaStatus</b> which is of type <b>cudaError_t</b> (see Nvidia documentation), throws with message <b>info</b> if the status is not success.  <a href="group__TasmanianAcceleration.html#ga67931ed3a58b5b1714e754c0b318f378">More...</a><br /></td></tr>
<tr class="separator:ga67931ed3a58b5b1714e754c0b318f378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee3920d8fc354dc01deab9d4e6264c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#gafee3920d8fc354dc01deab9d4e6264c4">TasGrid::AccelerationMeta::cublasCheckError</a> (void *cublasStatus, const char *info)</td></tr>
<tr class="memdesc:gafee3920d8fc354dc01deab9d4e6264c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes <b>cublasStatus</b> which is of type <b>cublasStatus_t</b> (see Nvidia documentation), throws with message <b>info</b> if the status is not success.  <a href="group__TasmanianAcceleration.html#gafee3920d8fc354dc01deab9d4e6264c4">More...</a><br /></td></tr>
<tr class="separator:gafee3920d8fc354dc01deab9d4e6264c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66027d59c5235e0d23ef5b30b32dce7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TasmanianAcceleration.html#ga66027d59c5235e0d23ef5b30b32dce7d">TasGrid::AccelerationMeta::cusparseCheckError</a> (void *cusparseStatus, const char *info)</td></tr>
<tr class="memdesc:ga66027d59c5235e0d23ef5b30b32dce7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes <b>cusparseStatus</b> which is of type <b>cusparseStatus_t</b> (see Nvidia documentation), throws with message <b>info</b> if the status is not success.  <a href="group__TasmanianAcceleration.html#ga66027d59c5235e0d23ef5b30b32dce7d">More...</a><br /></td></tr>
<tr class="separator:ga66027d59c5235e0d23ef5b30b32dce7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>RAII Memory Management</dt><dd>CUDA uses C-style of memory management with cudaMalloc(), cudaMemcopy(), cudaFree(), but templated C++ std::vector-style class is far more handy and more fail-safe. The <b>CudaVector</b> template class guards against memory leaks and offers more seamless integration between CPU and GPU data structures. See the <b>CudaVector</b> documentation for details.</dd></dl>
<dl class="section user"><dt>Streams and Handles Encapsulation</dt><dd>CUDA linear algebra libraries (as well as MAGAM), use streams and handles for all their calls. The handles have to be allocated, deleted, and passed around which causes unnecessary code clutter. Encapsulating the handles in a single <b>CudaEngine</b> class greatly simplifies the work-flow. Furthermore, some (sparse) linear operations require multiple calls to CUDA/MAGMA libraries, and it is easier to combine those into a single call to a <b>CudaEngine</b> method.</dd></dl>
<dl class="section user"><dt>Acceleration Metadata</dt><dd>The <b>AccelerationMeta</b> namespace offers several methods used throughout the library and in the testing:<ul>
<li>Tasmanian specific acceleration fallback logic</li>
<li>Reading CUDA device properties, e.g., number of devices or total memory</li>
<li>Error handling for common CUDA/cuBlas/cuSparse calls</li>
</ul>
</dd></dl>
<dl class="section user"><dt>C++ Wrappers to Fortran BLAS API</dt><dd>The standard BLAS API follows Fortran calling conventions, e.g., call by value and underscore at the end of function names. A C++ wrapper is provided that handles Tasmanian specific cases of dense matrix-matrix and matrix-vector multiplication using C++ compatible API. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga61035998929e409891c7b113651f2051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61035998929e409891c7b113651f2051">&#9670;&nbsp;</a></span>dtrans2can()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasCUDA::dtrans2can </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pad_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>gpu_trans_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>gpu_trans_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_x_transformed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>gpu_x_canonical</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses custom kernel to convert <b>transformed</b> points to <b>canonical</b> points, all arrays live on the CUDA device. </p>
<p>The array <b>gpu_x_transformed</b> is provided by the user and must be of size <b>num_x</b> times <b>dims</b>. The points are stored contiguously in strides of <b>dim</b> (identical to all other calls). In order to facilitate contiguous memory access, it is most efficient to assign each thread to different dimension, but the dimensions are much less than the threads. Thus, we pad the transforms <b>gpu_trans_a</b> and <b>gpu_trans_b</b> as if they are applied to much larger vectors (of dimension <b>pad_size</b>). The <b>pad_size</b> must be a multiple of <b>dims</b>, but <b>num_x</b> doesn't have to divide into <b>pad_size</b>. The <b>gpu_trans_a</b> and <b>gpu_trans_b</b> must have length <b>pad_size</b> and must contain the rate and shift of the transform (<b>not</b> the upper/lower limits).</p>
<p>The <b>use01</b> indicates whether to use canonical interval (0, 1) or (-1, 1). This is called from <b><a class="el" href="classTasGrid_1_1AccelerationDomainTransform.html#a762cc84e5ed19d823d0829b19bb060d4" title="Transform a set of points, used in the calls to evaluateHierarchicalFunctionsGPU() ...">AccelerationDomainTransform::getCanonicalPoints()</a></b>.</p>
<p>See the implementation of <b>AccelerationDomainTransform::load()</b> for more details. </p>

</div>
</div>
<a id="ga487792341ced3451cae56b4afeeb21cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga487792341ced3451cae56b4afeeb21cd">&#9670;&nbsp;</a></span>devalpwpoly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasCUDA::devalpwpoly </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>gpu_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the basis functions for a local polynomial grid using the <b>DENSE</b> algorithm. </p>
<p>Used for basis evaluations in <b>GridLocalPolynomial</b> with <b>order</b> (0, 1, and 2) and <b>rule</b>. The grid has <b>num_dimensions</b> and <b>num_basis</b> functions (equal to the number of points in the grid). The number of locations to evaluate is <b>num_x</b>, and <b>gpu_x</b> must have size <b>num_x</b> times <b>num_dimensions</b>, and <b>gpu_x</b> must be on a canonical interval. The output matrix <b>gpu_y</b> has dimension <b>num_basis</b> (contiguous dimension) times <b>num_x</b>.</p>
<p>The grid nodes and the associated support are "encoded" in <b>gpu_nodes</b> and <b>gpu_support</b>, where negative support is used to handle special cases such as global support on level 1 (rule semi-localp). The interpretation of the negative support must be synchronized between the kernel <b>tasgpu_devalpwpoly_feval()</b> and <b>GridLocalPolynomial::encodeSupportForGPU()</b>. </p>

</div>
</div>
<a id="ga9dd5f8cfd7fb8789dedfe6df281c93fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd5f8cfd7fb8789dedfe6df281c93fe">&#9670;&nbsp;</a></span>devalpwpoly_sparse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasCUDA::devalpwpoly_sparse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga145e27d5ae92acdd5f74149c6d4f2ca2">TypeOneDRule</a>&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_hpntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_hindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_hroots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_spntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_sindx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpu_svals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the basis functions for a local polynomial grid using the <b>SPARSE</b> algorithm. </p>
<p>The inputs are identical to <b><a class="el" href="group__TasmanianAcceleration.html#ga487792341ced3451cae56b4afeeb21cd" title="Evaluate the basis functions for a local polynomial grid using the DENSE algorithm. ">devalpwpoly()</a></b> with the addition of hierarchy vectors <b>gpu_hpntr</b>, <b>gpu_hindx</b>, and <b>gpu_roots</b>. The hierarchy vectors define a series of trees, one for each entry in <b>gpu_roots</b>, and all three nodes combined are indexed from 0 to gpu_spntr.size(). The <b>gpu_hpntr</b> holds the offsets of the children of each node and the indexes of the children are stored in <b>gpu_sindx</b>. The format is identical to row compressed sparse matrix.</p>
<p>The output vectors <b>gpu_spntr</b>, <b>gpu_sindx</b> and <b>gpu_svals</b> form a row compressed matrix, e.g., in format that can directly interface with Nvidia cusparseDcsrmm2(). </p>

</div>
</div>
<a id="ga08ad47955a961ca1f8fe8edbf145e023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08ad47955a961ca1f8fe8edbf145e023">&#9670;&nbsp;</a></span>devalseq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasCUDA::devalseq </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>gpu_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the basis for a Sequence grid. </p>
<p>The evaluation points are defined on a canonical interval and given in <b>gpu_x</b> with size <b>dims</b> times <b>num_x</b>. The <b>max_levels</b> indicates the maximum level in each direction (one more than the vector stored in the GridSequence data structure), the vector is required to compute the offsets of the intermediate cache for the Newton polynomials. The <b>points</b> holds the same information as the <b><a class="el" href="classTasGrid_1_1MultiIndexSet.html" title="Class that stores multi-indexes in sorted (lexicographical) order. ">MultiIndexSet</a></b>, but in transposed order, i.e., the dimensions of the multi-indexes are contiguous. The kernel handles one dimension at a time, hence the switched order compared to the CPU which handles one multi-index at a time. The <b>ndoes</b> vector has the cached 1D nodes and <b>coeffs</b> holds the cached coefficients of the Newton polynomials.</p>
<p>The output is <b>gpu_result</b> which must have dimension <b>num_x</b> by <b>num_nodes.size()</b> / <b>dims</b>. </p>

</div>
</div>
<a id="ga7c56ddb709fef22da7d0d8bcb1c79f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c56ddb709fef22da7d0d8bcb1c79f11">&#9670;&nbsp;</a></span>devalfor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasCUDA::devalfor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_levels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>gpu_wreal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt;::value_type *&#160;</td>
          <td class="paramname"><em>gpu_wimag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the basis for a Fourier grid. </p>
<p>The logic is identical to <b><a class="el" href="group__TasmanianAcceleration.html#ga08ad47955a961ca1f8fe8edbf145e023" title="Evaluate the basis for a Sequence grid. ">devalseq()</a></b>, except the Fourier polynomials do not require nodes or coefficients. The output is two real arrays of size <b>num_x</b> by <b>num_nodes.size()</b> / <b>dims</b> corresponding to the real and complex parts of the basis. </p>

</div>
</div>
<a id="ga37c22f5fc8cf3679ec0b1c9f70db82dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37c22f5fc8cf3679ec0b1c9f70db82dc">&#9670;&nbsp;</a></span>devalglo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::TasCUDA::devalglo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_nested</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_clenshawcurtis0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>gpu_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>coeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tensor_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>nodes_per_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>offset_per_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map_dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>active_tensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>active_num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>dim_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map_tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTasGrid_1_1CudaVector.html">CudaVector</a>&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>map_reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>gpu_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the basis for Global grid. </p>
<p>The logic is more complicated due to the more general nature of the grid. </p>

</div>
</div>
<a id="ga7ae184192f6d2bca2a9887d36db62668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae184192f6d2bca2a9887d36db62668">&#9670;&nbsp;</a></span>getIOAccelerationString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> TasGrid::AccelerationMeta::getIOAccelerationString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the string (coming from C or Python) into an enumerated type. </p>

</div>
</div>
<a id="gac2e20edfabde6a82e74b40fb6bac1047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2e20edfabde6a82e74b40fb6bac1047">&#9670;&nbsp;</a></span>getIOAccelerationString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TasGrid::AccelerationMeta::getIOAccelerationString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>accel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the enumerated type to a string, the inverse of <b><a class="el" href="group__TasmanianAcceleration.html#ga7ae184192f6d2bca2a9887d36db62668" title="Convert the string (coming from C or Python) into an enumerated type. ">getIOAccelerationString()</a></b> </p>

</div>
</div>
<a id="ga10839c9ae1b3663b8746b56d83fc081f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10839c9ae1b3663b8746b56d83fc081f">&#9670;&nbsp;</a></span>getIOAccelerationInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TasGrid::AccelerationMeta::getIOAccelerationInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>accel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the integer (coming from Fortran) into an enumerated type. </p>

</div>
</div>
<a id="ga685cda2cf2d7660ee8f630fa8f2ca647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685cda2cf2d7660ee8f630fa8f2ca647">&#9670;&nbsp;</a></span>getIOIntAcceleration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> TasGrid::AccelerationMeta::getIOIntAcceleration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>accel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the enumerated type to an integer, the inverse of <b><a class="el" href="group__TasmanianAcceleration.html#ga10839c9ae1b3663b8746b56d83fc081f" title="Convert the integer (coming from Fortran) into an enumerated type. ">getIOAccelerationInt()</a></b> </p>

</div>
</div>
<a id="ga61e7f9cea7355424ac39b404657a30bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e7f9cea7355424ac39b404657a30bc">&#9670;&nbsp;</a></span>isAccTypeGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TasGrid::AccelerationMeta::isAccTypeGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>accel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <b>true</b> if <b>accele</b> is cuda, cublas or magma. </p>

</div>
</div>
<a id="gae5a698d63fdc95b913db1ea966dda5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a698d63fdc95b913db1ea966dda5eb">&#9670;&nbsp;</a></span>getAvailableFallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a> TasGrid::AccelerationMeta::getAvailableFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581">TypeAcceleration</a>&#160;</td>
          <td class="paramname"><em>accel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements fallback logic, if <b>accel</b> has been enabled through CMake then this returns <b>accel</b>, otherwise it returns the "next-best-thing". </p>
<p>This function always returns a valid acceleration type. The fallback logic is documented with the enumerated type <b><a class="el" href="group__SGEnumerates.html#ga344ee5be5b77f2ff8e7c98f97ab40581" title="Types of acceleration for TasmanianSparseGrid::evaluateFast() and TasmanianSparseGrid::evaluateBatch(...">TasGrid::TypeAcceleration</a></b>. </p>

</div>
</div>
<a id="ga1a279855d78d5ab68875e7d46231621e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a279855d78d5ab68875e7d46231621e">&#9670;&nbsp;</a></span>getNumCudaDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TasGrid::AccelerationMeta::getNumCudaDevices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of visible CUDA devices, uses cudaGetDeviceCount() (see the Nvidia documentation). </p>

</div>
</div>
<a id="ga69cd13800b0e80a73e624dcae1ffc7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69cd13800b0e80a73e624dcae1ffc7f6">&#9670;&nbsp;</a></span>setDefaultCudaDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::AccelerationMeta::setDefaultCudaDevice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deviceID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the active device for this CPU thread using cudaSetDevice() (see the Nvidia documentation). </p>
<p>The <b>deviceID</b> must be a valid ID (between 0 and <a class="el" href="group__TasmanianAcceleration.html#ga1a279855d78d5ab68875e7d46231621e" title="Return the number of visible CUDA devices, uses cudaGetDeviceCount() (see the Nvidia documentation)...">getNumCudaDevices()</a> -1). </p>

</div>
</div>
<a id="gaecd328232c62eeba7fc02f84bc8ac62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecd328232c62eeba7fc02f84bc8ac62c">&#9670;&nbsp;</a></span>getTotalGPUMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long TasGrid::AccelerationMeta::getTotalGPUMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deviceID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the memory available in the device (in units of bytes), uses cudaGetDeviceProperties() (see the Nvidia documentation). </p>
<p>The <b>deviceID</b> must be a valid ID (between 0 and <a class="el" href="group__TasmanianAcceleration.html#ga1a279855d78d5ab68875e7d46231621e" title="Return the number of visible CUDA devices, uses cudaGetDeviceCount() (see the Nvidia documentation)...">getNumCudaDevices()</a> -1). </p>

</div>
</div>
<a id="gab93e9af5b4f1c940109194cb93c77e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab93e9af5b4f1c940109194cb93c77e49">&#9670;&nbsp;</a></span>getCudaDeviceName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string TasGrid::AccelerationMeta::getCudaDeviceName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>deviceID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a character array that is a copy of the CUDA device name, uses cudaGetDeviceProperties() (see the Nvidia documentation). </p>
<p>The <b>deviceID</b> must be a valid ID (between 0 and <a class="el" href="group__TasmanianAcceleration.html#ga1a279855d78d5ab68875e7d46231621e" title="Return the number of visible CUDA devices, uses cudaGetDeviceCount() (see the Nvidia documentation)...">getNumCudaDevices()</a> -1). The character array has to be manually deleted to avoid memory leaks. This causes issues between different versions of CUDA, Nvidia uses fixed length character arrays and Tasmanian makes a copy; sometimes different versions of CUDA use different name length which causes unexpected crashes on the CUDA side. </p>

</div>
</div>
<a id="gab20fa738772cd08992706e30045a5569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20fa738772cd08992706e30045a5569">&#9670;&nbsp;</a></span>recvCudaArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::AccelerationMeta::recvCudaArray </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gpu_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cpu_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a device array to the main memory, used for testing only, always favor using <b><a class="el" href="classTasGrid_1_1CudaVector.html" title="Template class that wraps around a single CUDA array, providing functionality that mimics std::vector...">CudaVector</a></b> (if possible). </p>

</div>
</div>
<a id="ga1217bdc16f561392b66e9af4b72d4f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1217bdc16f561392b66e9af4b72d4f82">&#9670;&nbsp;</a></span>delCudaArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::AccelerationMeta::delCudaArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate device array, used primarily for testing, always favor using <b><a class="el" href="classTasGrid_1_1CudaVector.html" title="Template class that wraps around a single CUDA array, providing functionality that mimics std::vector...">CudaVector</a></b> (if possible). </p>

</div>
</div>
<a id="ga67931ed3a58b5b1714e754c0b318f378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67931ed3a58b5b1714e754c0b318f378">&#9670;&nbsp;</a></span>cudaCheckError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::AccelerationMeta::cudaCheckError </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cudaStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes <b>cudaStatus</b> which is of type <b>cudaError_t</b> (see Nvidia documentation), throws with message <b>info</b> if the status is not success. </p>

</div>
</div>
<a id="gafee3920d8fc354dc01deab9d4e6264c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafee3920d8fc354dc01deab9d4e6264c4">&#9670;&nbsp;</a></span>cublasCheckError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::AccelerationMeta::cublasCheckError </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cublasStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes <b>cublasStatus</b> which is of type <b>cublasStatus_t</b> (see Nvidia documentation), throws with message <b>info</b> if the status is not success. </p>

</div>
</div>
<a id="ga66027d59c5235e0d23ef5b30b32dce7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66027d59c5235e0d23ef5b30b32dce7d">&#9670;&nbsp;</a></span>cusparseCheckError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TasGrid::AccelerationMeta::cusparseCheckError </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cusparseStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes <b>cusparseStatus</b> which is of type <b>cusparseStatus_t</b> (see Nvidia documentation), throws with message <b>info</b> if the status is not success. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
